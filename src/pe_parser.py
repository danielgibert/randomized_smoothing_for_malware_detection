import lief
import hashlib
import array
from collections import OrderedDict
from typing import Tuple
import copy
import numpy as np


class PEParser(object):
    def __init__(self, exe_filepath: str = None):
        self.sha256 = None
        self.exe_filepath = exe_filepath
        self.lief_errors = (lief.bad_format, lief.bad_file, lief.pe_error, lief.parser_error, lief.read_out_of_bound,
                            RuntimeError)
        if exe_filepath:
            self.bytez, self.bytez_int_list, self.lief_binary = self._is_valid(self.exe_filepath)

    def _is_valid(self, exe_filepath):
        bytez = self._get_bytez(exe_filepath)
        bytez_int_list = self._convert_to_int(bytez)
        # Check that before the modifications the file is valid!
        lief_binary = self._get_binary(bytez_int_list)
        return bytez, bytez_int_list, lief_binary

    def _get_bytez(self, exe_filepath):
        with open(exe_filepath, "rb") as f:
            bytez = f.read()
            self.sha256 = hashlib.sha256(bytez).hexdigest()
        return bytez

    def _convert_to_int(self, bytez):
        return list(bytez)

    def _get_binary(self, bytez_int_list):
        try:
            binary = lief.PE.parse(bytez_int_list)
        except self.lief_errors as lief_err:
            #print("LIEF error: ", str(lief_err))
            binary = None
            print("LIEF error!")
            raise lief_err
        except Exception as e:  # everything else (KeyboardInterrupt, SystemExit, ValueError):
            #print("General errors: ", str(e))
            print("General error!")
            raise e
        return binary

    def _build_binary(self, binary, dos_stub=False, imports=False, overlay=False, relocations=False,
                          resources=False, tls=False):
        builder = lief.PE.Builder(binary)  # write the file back as bytez
        if (dos_stub):
            builder.build_dos_stub(dos_stub)  # rebuild DOS stub
        if (imports):
            builder.build_imports(imports)  # rebuild IAT in another section
            builder.patch_imports(imports)  # patch orig. import table with trampolines to new import table
        if (overlay):
            builder.build_overlay(overlay)  # rebuild overlay
        if (relocations):
            builder.build_relocations(relocations)  # rebuild relocation table in another section
        if (resources):
            builder.build_resources(resources)  # rebuild resources in another section
        if (tls):
            builder.build_tls(tls)  # rebuilt TLS object in another section
        builder.build()  # perform the build process
        return builder

    def _binary_to_bytez(self, binary, dos_stub=False, imports=False, overlay=False, relocations=False, resources=False, tls=False):
        self.lief_binary = binary
        self.builder = self._build_binary(
            self.lief_binary,
            dos_stub=dos_stub,
            imports=imports,
            overlay=overlay,
            relocations=relocations,
            resources=resources,
            tls=tls
        )
        self.bytez_int_list = self.builder.get_build()
        self.bytez = array.array('B', self.bytez_int_list).tobytes()
        return self.bytez, self.bytez_int_list, self.lief_binary
    
    def get_section_table_information(self):
        section_table_information = OrderedDict()
        for section in self.lief_binary.sections:
            # print(section.name, section.pointerto_raw_data, section.size)
            section_table_information[section.name] = {
                "name": section.name,
                "virtual_address": section.virtual_address,
                "virtual_size": section.virtual_size,
                "raw_address": section.pointerto_raw_data,
                "offset": section.offset,  # The offset from the beginning of the file
                "size": section.size,
                "characteristics": [x.name for x in section.characteristics_lists]
            }
            # print(self.lief_binary.get_content_from_virtual_address(section.virtual_address, section.virtual_size)[:10])
            # print(self.bytez_int_list[section.pointerto_raw_data: section.pointerto_raw_data+10])
        return section_table_information

    def get_header_information(self):
        return OrderedDict({
            "size": self.lief_binary.sizeof_headers
        })

    def get_overlay_information(self):
        return OrderedDict({
            "size": len(self.lief_binary.overlay),
            "content": self.lief_binary.overlay
        })

    def bytez_to_numpy(self, padding_value: int = 256):
        x = copy.deepcopy(self.bytez)
        if padding_value == 0.0:
            x = np.frombuffer(x, dtype=np.uint8).astype(np.int16) + 1  # index 0 will be special padding index
        else:
            x = np.frombuffer(x, dtype=np.uint8).astype(np.int16)  # index 256 will be special padding index
        return x

